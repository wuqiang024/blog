# 作用域和闭包
1、作用域
我们来先说一下变量的作用域。变量的作用域一般分为两种: 全局作用域和局部作用域。
全局作用域: 函数最外层定义的变量，任何函数内部都可以访问到。
例如:

```js
var a = '1';
function change() {
    console.log(a);
};
change()
```

局部作用域: 和全局作用域不同，局部作用域只能允许自身内部调用变量，外部函数无法访问。
例如:

```js
function num() {
    var b = '2';
};
num();
console.log(b); // undefined
```

需要注意的是，在函数内部声明一个变量的时候，一定要记得用var定义，不然相当于声明了一个全局变量。
例如:

```js
function change() {
    num = 2;
}
change();
console.log(num);
```

需要注意的是，函数内部存在的变量提升问题。
我们先看下面例子。

```js
var num1 = 1;
function one() {
    console.log(num1); // undefined
    var num1 = 2;
    console.log(num1) // 2
}
```

其实上面的例子等价于:

```js
var num1 = 1;
function one() {
    var num1;
    console.log(num1);
    num1 = 1;
    console.log(num1); // 2
}
```

不难看出，这是存在的函数内部变量提升的现象。

或许对概念不清的同学对第一个例子有点疑惑，认为第一个打印出来的应该是1，而不是undefined。
为什么呢？其实one()函数内部声明了num1,one()此时就是一个局部作用域，在内部没有声明num1的情况下，是会直接获取全局变量num1。
但是在局部作用域声明了num1之后，num1这个变量会提升。如第一个例子，当第一次console.log(num1)的时候，就相当于var num1，定义了一个变量但没有赋值，第二次打印，会打印出赋值后的num1，就像上面的第二个例子。

拓展: 在这里，想拓展一下几种常见的声明变量的方式。

* var: 如果在当前函数内部声明一个变量，则作用范围在函数内部；如果在最外层声明，则作为全局变量；如果未使用var定义直接使用变量，则会报错。
* const: 具有块级作用域的特征，在同一个作用域中，变量名只能声明一次，不存在变量提升。const声明的变量必须是个常量。
* let: 跟const几乎类似，但是最主要的区别是let声明的是一个变量，const声明的必须是一个常量。

不同之处:
* var 存在变量提升，let和const不会
* var在函数内部同一个变量可以重复声明，而在同一个块级作用域内部，let和const只能声明一次，并且const声明的是个常量，不能修改。
* var 声明的变量属于函数作用域，let和const声明的变量属于块级作用域。

## 闭包
简单的说，闭包有两个作用: 一就是能够读取其他函数内部变量的函数，二是让这些外部变量始终存在内存中。
闭包可以避免使用全局变量，防止变量污染，但是过多使用会造成内存泄漏。

举个例子，我想要获取一个函数内部的变量:

```js
var num = 200;
function f1() {
    var num = 100;
    return num
}
f1() // 100
var fn = f1();
fn()
```

这显然是不行的，fn获取不到f1内部的变量。这时候我们可以考虑在f1内部返回一个函数看看结果。

```js
var num = 200;
function f1() {
    var num = 100;
    return function() {
        return num;
    }
}
var fn = f1();
fn();
```

通过在函数内部返回一个函数，外部函数可以根据返回的函数获取到原来函数内部的变量，这就体现了闭包的作用。