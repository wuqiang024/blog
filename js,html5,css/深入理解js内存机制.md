# 深入理解js内存机制
***
js的内存机制在很多前端开发者看来不是那么重要，但是如果你想深入学习js，并将它利用好，打造高质量高性能的前端应用，就必须要了解js的内存机制。对于内存机制理解了以后，一些基本的问题比如最基本的引用数据类型和引用传递是怎么回事?浅复制和深复制有什么不同?还有闭包，原型等问题就迎刃而解了。

## js类型
***
在js中,js的类型分为两个大类，分别是基本数据类型和引用数据类型。在ES5中有5种简单类型(也就是上面说的基本数据类型):
Undefined, Null, String, Number, Boolean。还有一种复杂数据类型Object。Object本质上是由一组无序的键值对组成。其中可以算在Object中的还有Array和Function.

在内存中，基本数据类型放在栈中，引用数据类型放在堆中。说到这里就要说一下内存空间了，一般来说,js内存空间分为栈，堆，池(一般也会归类到栈中)。其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。

但是有一个变量是特殊的，那就是闭包中的变量，闭包中的变量并不保存在栈内存中，而是保持在堆内存中，这也就解释了函数之后为什么闭包还能引用到函数中的变量。

```js
function A() {
    let a = 1;
    function B() {
        console.log(a);
    }
    return B
}
```

闭包的简单定义: 函数A返回了一个函数B，并且函数B中使用了函数A的变量，函数B就被称为闭包。

函数A弹出调用栈后，函数A的变量这时候是存储在堆上的，所以B函数依旧能引用到函数A中的变量。现在的JS引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。

## 引用数据类型和堆内存
***
与其他语言不同，js的引用数据类型，比如数组Array，他们的值大小是不固定的。引用数据类型的值时保存在堆内存中的对象。JS不允许直接访问堆内存的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以粗浅的理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。

为了更好的搞懂变量对象与堆内存，我们可以结合以下例子和图解进行理解。

var b = {m:20}; // 变量b存在栈中，对于的值就是一个索引指向对象{m:20}; {m:20}作为对象存在于堆内存中。

![https://user-gold-cdn.xitu.io/2018/11/29/1675fe242adbeca8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1](https://user-gold-cdn.xitu.io/2018/11/29/1675fe242adbeca8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用(或者地址指针)，然后再从堆内存中获取我们需要的数据。

如此，就会出现我们经常被问到的关于引用数据类型的值的问题了。
```js
var x = 30;
var b = x;
x += b;
console.log(b);
```
上面的问题很容易解答，就是30；x的操作不会对b有什么影响，因为在变量对象中的数据发生复制行为时，系统会自动的为新的变量分配一个新值。var b = a执行后，虽然a和b的值都是20，但是他们已经是互不影响的值了。但是下面这个问题就有意思了。

```js
var x = {m:1};
var y = x;
x.m++;
console.log(y.m);
```

通过输出我们发现答案是2.这是因为我们通过var y = x是执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们互相独立，但是在变量对象中访问到的具体对象实际上是同一个。

## 垃圾回收
***
在js中有垃圾回收机制，其作用是回收过期无效的变量，以防止内存泄漏。这些工作不需要我们去管理什么时候进行垃圾回收，js会自动进行。

下面来看JS垃圾回收机制会什么时候回收变量。我们写代码的时候是区分全局变量和局部变量的。我们看一下局部变量和全局变量的销毁。

* 局部变量: 局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾回收机制很容易做出判断并回收。
* 全局变量: 全局变量什么时候需要自动释放内存空间很难判断，所以在开发中尽量避免使用全局变量，以提高内存有效使用率。

## 垃圾回收算法
***
现在各大浏览器中常用的垃圾回收有两种方法: 标记清除，引用计数。

### 引用计数
***
现代浏览器基本上已经不再使用了，在这里我们做一下简单的介绍。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给这个变量时，则这个值的引用次数就是1，相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1.当这个引用次数变为0时，则说明没有办法再访问这个值了，因而就可以将其所占内存空间给收回来。这样垃圾收集器下次再运行时，他就会释放那些引用次数为0的值所占的内存。简单来说是看一个对象是否有指向他的引用。如果没有其他对象指向他了，就说明该对象不需要了。

```js
var person = {
    age: 12,
    name: 'aaa'
};

person.name = null // 虽然name设置为null，但person对象还有指向name的引用，因此name不会回收
var p = person;
person = 1; // 原来的person对象被赋值为1，但因为有新的引用p指向原person对象，因此他不会被回收
p = null; // 原person对象已经没有引用，很快被回收
```

但是，如果出现了循环引用，那么这种方式就会存在一个大bug。
```js
function bigBug() {
    var objA = new Object();
    var objB = new Object();
    objA.bug1 = objB;
    objB.bug2 = objA;
}
```
在上面这个例子中，ab两个对象是互相引用的，也就是他们的引用次数永远为2，如果不进行其他操作的话，这样的互相引用如果大量使用的话，就会造成内存泄漏。虽然说现在主流的浏览器不再使用了，但是之前的IE版本还是那样，所以在写代码的时候尽量避免。避免的方法就是在不使用的时候进行手动解除循环绑定。
```js
objA.bug1 = null
objB.bug2 = null
```

### 标记清除
***
标记清除算法将'不再使用的对象'标记为'无法到达的对象‘。即从根部(在JS中就是全局对象)出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。每一个变量都有自己的使用环境，当进入环境后，垃圾回收机制就会给他打上一个'进入环境'的标签，从逻辑上来讲，系统不能清除处于环境中的变量，因为只要是在环境中就有可能被用到。当其离开环境时，会给其打上'离开环境'的标签，这时候便可以进行回收了。

## 内存泄漏
***
内存泄漏可能对于前端开发者比较陌生，但是你肯定遇到过浏览器卡死的现象，卡死的原因就是可能因为一个死循环导致的内存泄漏。所以对于持续运行的服务进程，必须及时释放不再用到的内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。对于不再用到的内存，没有及时释放，就叫做内存泄漏。
如果想模拟的话，可以按下面的步骤进行操作:

* 打开开发者工具，选择Memory
* 在右侧的Select profiling type字段选择timeline
* 点击左上角的录制按钮
* 在页面上进行各种操作，模拟用户的使用
* 一段时间后，点击左上角的stop按钮，面板上就会显示这段时间的内存占用情况。

![https://user-gold-cdn.xitu.io/2018/11/29/1675fe242cd76fa6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1](https://user-gold-cdn.xitu.io/2018/11/29/1675fe242cd76fa6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)