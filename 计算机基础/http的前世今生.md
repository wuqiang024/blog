# HTTP的前世今生: 一次性搞懂HTTP、HTTP、SPDY、HTTP2
***
作为互联网通信协议的一员老将，HTTP协议走到今天已经经历了三次版本的变动，现在最新版本是HTTP2.0,相信大家早已耳熟能详。今天就给大家好好介绍一下HTTP的前世今生。

## HTTP/0.9
***
HTTP的最早版本诞生在1991年，这个最早版本和现在比起来极其简单，没有HTTP头，没有状态码，甚至版本号都没有，后来他的版本号才被定为0.9来和其他版本的HTTP区分。HTTP/0.9只支持一种方法-GET,请求只有一行。`GET /hello.html`。响应也是非常简单，只包括HTML文档本身。
```html
<HTML>
    HELLO WORLD
</HTML>
```
当TCP建立连接后，服务器向客户端返回HTML格式的字符串。发送完毕后就关闭TCP连接。由于没有状态码和错误代码，如果服务器处理的时候发生错误。只会传回一个特殊的包含问题描述的HTML文件。这就是最早的HTTP/0.9版本。

## HTTP/1.0
***
1996年，HTTP/1.0版本发布，大大丰富了HTTP的传输内容，除了文字，还可以发送图片，视频等，这为互联网的发展奠定了基础。相比HTTP/0.9,HTTP/1.O主要有以下特性。
* 请求与响应支持HTTP头，增加了状态码，响应对象的一开始是一个响应状态行。
* 协议版本信息需要随着请求一起发送，支持HEAD,POST方法。
* 支持传输HTML文件以外其他类型的内容。

一个典型的HTTP/1.0请求像这样。

```js
GET /index.html HTTP/1.0
User-Agent:NCSA_Mosaic/2.0(windows3.1)

200 OK
Date: Tue, 15 Nov 1996 08:12:31 GMT
Server: CERN/3.0 libwww/2.17
Content-Type: text/html

<html>
一个包含图片的页面<img src="/simle.gif">
</html>
```

## HTTP/1.1
***
在HTTP/1.0发布几个月后，HTTP/1.1就发布了。HTTP/1.1更多的是作为对HTTP/1.0的完善，在HTTP/1.1中，主要具有如下改进:

* 可以复用连接
* 增加pipeline: HTTP管线化是将多个HTTP请求整批提交的技术，而在传送过程中不需先等待服务器端的回应。管线化机制须通过永久连接完成。浏览器将HTTP请求大批提交可大幅缩短页面的加载时间，特别是在传输延迟较高的情况下，有一点需要注意的是，只有幂等的请求可以使用pipeline，如GET,HEAD等。
* chunked编码传输: 该编码将实体分块传送并逐块标明长度，直到长度为0块表示传输结束。这在实体长度未知时特别有用(比如由数据库动态产生的数据)
* 引入更多缓存控制机制: 如etag, cache-control
* 引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。
* 请求消息和响应消息都支持HOST头: 在HTTP1.0中认为每个服务器都绑定唯一的IP地址，因此，请求消息中的URL并没有传递主机名(hostname)。但是随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟机，并且他们共享一个IP地址。因此，HOST头的引入就很有必要了。
* 新增了OPTIONS,PUT,DELETE,TRACE,CONNECT方法。

虽然HTTP/1.1已经优化了很多点，作为一个目前使用最广泛的协议版本，已经能够满足很多网络需求，但是随着网页越来越复杂，甚至演变为独立的应用，HTTP/1.1逐渐暴露出了一些问题:

* 在传输数据时，每次都要重新建立连接，对移动端特别不友好
* 传输内容是明文，不够安全
* header内容过大，每次请求header变化不大，造成浪费
* keep-alive给服务器带来性能压力

为了解决这些问题，HTTPS和SPDY应运而生。

## HTTPS
***
HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
`HTTP+SSL=HTTPS`
HTTPS协议的主要内容可以分为两种，一种是建立信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。
HTTP和HTTPS的区别主要如下:

* HTTPS协议使用ca申请证书，由于免费整数较少，需要一定费用。
* HTTP是明文传输，HTTPS则是具有安全性的SSL加密传输协议。
* HTTP和HTTP使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443.

## SPDY
***
其实SPDY并不是新的一种协议，而是在HTTP之前做了一层会话层。
![https://segmentfault.com/img/remote/1460000016996545?w=328&h=154](https://segmentfault.com/img/remote/1460000016996545?w=328&h=154)

在2010年到2015年，谷歌通过实践一个实验性的SPDY协议，证明了一个在客户端和服务器端交换数据的另类方式。其收集了浏览器和服务器端的开发者的焦点问题，明确了响应数量的增加和解决复杂的数据传输。在启动SPDY这个项目时预设的目标是:

* 页面加载时间(PLT)减少50%
* 无需网站作者修改任何内容
* 将部署复杂性降至最低，无需变更网络基础设施
* 与开源社区合作开发这个新协议
* 收集真实性能数据，验证这个实验协议是否有效

为了达到降低目标，减少页面加载时间的目标，SPDY引入了一个新的二进制分帧数据层，以实现多向请求和响应，优先次序，最小化以及消除不必要的网络延迟，目的是更有效的利用底层TCP连接。

## HTTP/2.0
***
时间来到2015年，HTTP/2.O问世。特点是:

* 使用二进制分帧层: 在应用层与传输层之间增加一个二进制分帧层，以此达到在不改动HTTP的语义，HTTP方法，状态码，URL以及首部字段的情况下，突破HTTP1.1的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层上，HTTP2.0会将所有传输的信息分割为更小的消息和帧，并对他们采用二进制格式的编码，其中HTTP1.X的首部会被封装到Headers帧，而我们的request body则封装在Data帧里面。
* 多路复用: 对于HTTP/1.X，即使开启了长连接，请求的发送也是串行发送的，在带宽足够的情况下，对带宽的利用率不够，HTTP/2.0采用多路复用的方式，可以并行发送多个请求，提高对带宽的利用率。
* 数据流优先级: 由于请求可以并发发送了，那么如果出现了浏览器在等待关键的CSS或JS文件完成对页面的渲染时，服务器却在专注的发送图片资源的情况怎么办？HTTP/2.0对数据流可以设置优先级，这个优先级决定了客户端和服务端处理不同的流采用不同的优先级策略。
* 服务端推送: 在HTTP/2.0中，服务器可以向客户发送请求之外的内容，比如正在请求一个页面时，服务器会把页面相关的LOGO,CSS等文件直接推送到客户端，而不会等到请求来的时候再发送，因为服务器认为客户端会用到这些东西。这相当于在HTML文档内集合了所有的资源。
* 头部压缩: 使用首部表来跟踪和存储之前发送的键值对，对于相同的内容，不会再每次请求和响应时发送。

![https://segmentfault.com/img/remote/1460000016996548?w=1200&h=712](https://segmentfault.com/img/remote/1460000016996548?w=1200&h=712)

可以看到HTTP/2.0跟SPYD很相似，其实HTTP/2.0本来就是基于SPDY设计的，可以说是SPDY的升级版。
但是HTTP/2.0仍然有和SPDY不同的地方，主要有如下两点:

* HTTP2.0支持明文HTTP传输,而SPDY强制使用HTTPS
* HTTP2.0消息头的压缩算法采用HPACK,而非SPYD采用的DEFLATE