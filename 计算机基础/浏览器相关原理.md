# 浏览器相关原理
***

## chrome打开一个页面需要启动多少个进程?分别有哪些进程?
***

浏览器从关闭状态进行启动，然后新开一个页面至少需要一个网络进程，一个浏览器进程，一个GPU进程以及一个渲染进程，共四个进程；后续再新开标签页，浏览器，网络，GPU进程是共享的，不会重新启动，如果2个页面属于同一个站点的话，并且从A页面中打开的B页面，那么他们也会共用一个进程，否则会新开一个进程。

最新的Chrome浏览器包括: 1个浏览器主进程，1个GPU进程，1个网络进程，多个渲染进程和多个插件进程。

* 浏览器进程: 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能
* 渲染进程: 核心任务是将HTML，CSS和Javascript转换为用户可与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
* GPU进程: 其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页，Chrome的UI界面都选择采用GPU来绘制，这使得GPU称为浏览器的普遍需求。最后，Chrome在其多进程架构上也引入了GPU进程。
* 网络进程: 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面，直到最近才独立出来，成为一个单独的进程。
* 插件进程: 主要负责插件的运行，因插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

## 如何保证页面文件能完整的被送达浏览器？
***
互联网中的数据是通过数据包来传输的。数据包要在互联网上进行传输，就要符合网际协议(IP),互联网上不同的在线设备都有唯一的地址，地址只是一个数字，只要知道这个地址，就可以往这里发送信息。

如果想要把一个数据包从主机A发送到主机B，那么在传输之前，数据包上会被附加上主机B的IP地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机A本身的IP地址，有了这些信息主机B才可以回复信息给主机A。这些附加的信息会被装进一个叫IP头的数据结构里。IP头是IP数据包开头的信息，包含IP版本，源IP地址，目标IP地址，生存时间等信息。

IP是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给王者荣耀？因此，需要基于IP之上开发能与应用打交道的协议，最常见的是`用户数据包协议，简称UDP，和传输控制协议，简称TCP。

基本传输过程为:
1、上层将数据包交给传输层
2、传输层会在数据包前面附加上UDP头，组成新的UDP数据包，再将新的UDP数据包交给网络层
3、网络层再将IP头附加到数据包上，组成新的IP数据包，并交给底层
4、数据包被传输到主机B的网络层，在这里主机B拆开IP头信息，并将拆开来的数据部分交给传输层
5、在传输层，数据包中的UDP头会被拆开，并根据UDP中所提供的端口号，把数据部分交给上层的应用程序。
6、最终，数据包就发送到了主机B上层应用程序这里。

## UDP和TCP有什么区别?
***
* TCP协议在传输数据的时候要给段标号；UDP协议不
* TCP协议可靠；UDP协议不可靠
* TCP协议面向连接；UDP协议采用无连接
* TCP协议负载高，采用虚电路；UDP采用无连接
* TCP协议的发送方要确认接收方是否收到数据段(三次握手)
* TCP协议采用窗口技术和流控制

## TCP传输的详细过程是怎样的?
***
进行三次握手，建立TCP连接。

* 第一次握手: 建立连接。客户端发送连接请求报文，将SYN位置为1，Sequence Number为x; 然后，客户端进入SYN_SEND状态，等待服务器的确认。
* 第二次握手: 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段确认，设置Acknowledgment Number为x+1(Sequence Number + 1)； 同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段中),一并发送给客户端，此时服务器进入SYN_RECV状态。
* 第三次握手: 客户端收到服务器的SYN+ACK报文段。然后将Acknowlegement Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕后，客户端和服务端都进入ESTABLISHED状态，完成TCP三次握手。完成了三次握手，客户端和服务器端就可以开始传输数据了。

> ACK:此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值: 0和1，为1的时候表示应答域有效，反之为0.TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1.SYN(Synchronization):在连接建时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意连接，则应在响应报文中使用SYN=1和ACK=1，因此，SYN置1就表示这是一个连接请求或连接接受报文。FIN即完，终结的意思，用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

TCP连接建立后，浏览器就可以利用HTTP/HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since,则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200.

### 关闭TCP连接
***

* 第一次分手: 主机(可以是客户端，也可以是服务端)，设置sequence Number和Ackowlege Number，向主机2发送一个FIN报文段，此时，主机进入FIN_WAIT状态；这表示主机1没有数据要发送给主机2了。
* 第二次分手: 主机二收到了主机一发送的FIN报文段，向主机一回一个ACK报文段，Ackowlegement Number为Sequence Number加1；主机一进入FIN_WAIT_2状态；主机二告诉主机一，我同意你的关闭请求。
* 第三次分手: 主机二向主机一发送FIN报文段，请求关闭连接，同时主机二进入LAST_ACK状态；
* 第四次分手: 主机一收到主机二发送的FIN报文段，向主机二发送ACK报文段，然后主机一进入TIME_WAIT状态；主机二收到主机一的ACK报文段后，就关闭连接，此时主机一等2MSL后依然没有收到回复，则证明Server端已经正常关闭，那好，主机一也可以关闭连接了。

## 为什么很多点站点第二次打开速度会很快?
***
主要原因是第一次加载页面过程中，缓存了一些耗时的数据。那么，哪些数据会被缓存呢?

### DNS缓存
主要就是在浏览器本地把对应的IP和域名关联起来，这样在进行DNS解析的时候就很快。

### MemoryCache是指在内存中的缓存。
从优先级上来说，他是浏览器最先尝试去命中的一种缓存。从效率上来说，他是响应速度最快的一种缓存。内存缓存是块的，也是短命的，他和渲染进程生死相依，当进程结束后，也就是tab关闭后，内存里的数据也不复存在。

### 浏览器缓存
浏览器缓存也称HTTP缓存，分为强缓存和协商缓存。优先级高的是强缓存，在命中强缓存失败的情况下，才走协商缓存。

* `强缓存`
强缓存是利用HTTP头中的`Expires`和`Cache-Control`两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的expires和cache-control判断目标资源是否命中强缓存，若命中则直接从缓存中获取资源，不会再与服务器发生通信。

实现强缓存，过去我们一直用expires。当服务器返回响应时，在Response Headers中将过期时间写入expires字段。像这样:

`expires: Wed, 12 Sep 2019 06:12:18 GMT`

可以看到,expires是一个时间戳，接下来如果我们试图再向服务器请求资源，浏览器就会先对比本地时间和expires时间戳，如果本地时间小于expires时间戳，则直接去缓存中取这个资源。

这样的描述中不难看出，expires是有问题的，他最大的问题是对本地时间的依赖。如果服务端和客户端的时间设置可能不同，或者我直接去手动设置客户端的时间，那么expires将无法达到我们的预期。

考虑到expires的局限性，HTTP1.1新增了Cache-Control字段来完成expires的任务。expires能做的事情，Cache-Control都能做；expires完成不了的事情，Cache-Control也能做。因此，Cache-Control可以看作是expires的一个完全替代方案。在当下的前端实践里，我们继续使用expires的唯一目的就是向下兼容。

```
Cache-Control: max-age=31000000
```

在Cache-Control中，我们通过max-age来控制资源的有效期。max-age不是个时间戳，而是一个时间长度。在本例中，max-age是3100000秒，他意味着该资源在该时间段内都是有效的，完美的规避了时间戳的问题。

`Cache-Control相对于expires更加准确，它的优先级也更高。当Cache-Control与expires同时出现时，我们以Cache-Control为准。`

* `协商缓存`
协商缓存依赖于服务器与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求，下载完整的响应，还是从本地获取缓存的资源。如果服务器提示缓存资源未改动(Not Modified)，资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是304。

协商缓存的实现，从Last-Modified到Etag，Last-Modified是一个时间戳，如果我们启用了协商缓存，他会在首次请求时随着Response Headers返回。

随后我们每次请求时，会带上一个If-Modified-Since的时间戳字段，它的值正是上一次response返回给他的last-modified值。

服务器收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化。就会返回一个完整的响应内容，并在Response Headers中添加新的Last-Modified值，否则，返回如上图的304响应，Response Headers 不会再添加Last-Modified字段。

**使用Last-Modified存在的一些弊端，这其中最常见的就是这样两场景。**
* 我们编辑了文件，但是文件内容没有发生改变，服务器并不清楚我们是否真正改变了文件，他仍然通过最后编辑时间进行判断。因此这个资源在再次请求时，会被当做新资源，进而引发一次完整的响应。
* 我们修改文件的速度过快，比如花了100MS进行改动，由于if-modified-since只能检查以秒为单位的时间差。所以他是感知不到这个改动的。

这两个场景其实都指向了同一个bug-服务器并没有正确感知文件的变化。为了解决这样的问题，Etag作为Last-Modified的补充出现了。

Etag的生成过程需要服务器额外付出开销，会影响服务器端的性能，这是它的弊端。因此启用Etag需要我们审时度势。正如我们刚刚所提到的-Etag并不能替代Last-Modified，它只能作为Last-Modified的补充和强化存在。

`Etag在感知文件变化上比Last-Modified更加准确，优先级也更高。当Etag和Last-Modified同时存在时，以Etag为准。`

* `Service Worker Cache`
Service Worker是一种独立于主线程之外的JavaScript线程。它脱离于浏览器窗体，因此无法直接访问DOM。这样独立的个性是的Service Worker的个人行为无法干扰页面的性能。这个幕后工作者可以帮我们实现离线缓存，消息推送和网络代理等功能。我们借助Service Worker实现的功能就称为Service Worker Cache。

Service Worker的生命周期包括install, active, working三个阶段。一旦Service Worker被install，只会在active和working之间切换，除非我们主动终止他。这是它可以用来实现离线存储的重要先决条件。

* `Push Cache`
Push Cache是指HTTP2在server push阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶段，应用范围有限不代表不重要--HTTP2是趋势，是未来。在它还未被推而广之的此时此刻，仍希望大家能对Push Cache的关键特性有所了解。

* Push Cache是缓存的最后一道防线，浏览器只有在Memery Cache、HTTP Cache和Service Worker Cache均未命中的情况下才会去询问Push Cache。
* Push Cache是一种存在于会话阶段的缓存，当session终止时，缓存也随之释放。
* 不同的页面只要共享了同一个HTTP2连接，那么他们就可以共享同一个Push Cache。


